# Fork-modify-search
github fork仓库对原始仓库修改未合并的查询。方便快速的找到小码哥fork某仓库之后做了修改并未合并到主仓库的变更。
可以用来学习心仪项目在其他同道中人的手中做的改变。爱屋及乌，学习一下别人怎么搞的。

**震惊！！！沙雕了，github提供这样的功能。只不过我不知道。尴尬了一地。**

*某个月黑风高的夜晚，突然发现，我的fork版本被别人fork了，一个疑问出现，他是怎么知道的？冥冥中有种不祥的预感，然后，我就发现，我是个垃圾。非常的垃圾*

**不过侥幸一点，因为此项目能直接显示commit log内容，这点上还是比github提供的功能强一丢丢。还是有薛微的存在价值**

## 实现思路
获取某个仓库的fork 列表，遍历查找到每个fork仓库，查看每个仓库的状态情况。存在ahead commit的视为对原始仓库做了修改。
并且获取到ahead commit的commit数量，到对应仓库的commit log页面抓取相应数量的commit log。自此完成发现小码哥的杰作以及小码哥的修改概览

## 状态
基本逻辑功能都有了。可以顺利实现预期效果。存在的问题，容易被github ratelimit。可以暴力的调节请求间等待时间缓解
但是不能根本上解决。主要原因在于使用的爬虫架子semi的小问题，未将线程数定义暴露出来。之前自己改过可定义线程数量的版本。但是当时使用了github作为maven托管，
年久失修，不想再处理了。感兴趣的，可以搞个shell版本的出来。这样大家使用起来更加的happy。或者托管到自己的服务器上暴露http服务。也是很happy的。

## 使用（发现不可用，欢迎提交pr，或者提醒我）
1. 填写自己的目标项目，格式： githubUserName/projectName。给这个变量赋值即可 name.auh.tool.Main.TARGET_REPO
2. 启动项目（spirng boot启动）
3. logs目录查看result.log文件，获得结果

## 最新更新
有问题总是要解决的。经过我反复的思考。灵感一来，我hack了seimi的逻辑。通过不修改起内部源码的方式。解除他的控制权，拿回控制权。
然后，自己来处理他的初始化。这样一来，线程数自由。目的达到了。同时测试发现，效果非常理想。基本上被ratelimit的概率几乎消失了。赞！！！
